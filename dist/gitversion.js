/* eslint-disable */
//prettier-ignore
module.exports = {
name: "@yarnpkg/plugin-gitversion",
factory: function (require) {
var plugin=(()=>{var Re=Object.create,O=Object.defineProperty;var Te=Object.getOwnPropertyDescriptor;var Ve=Object.getOwnPropertyNames;var $e=Object.getPrototypeOf,Be=Object.prototype.hasOwnProperty;var Ge=t=>O(t,"__esModule",{value:!0});var g=t=>{if(typeof require!="undefined")return require(t);throw new Error('Dynamic require of "'+t+'" is not supported')};var S=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),Ne=(t,e)=>{for(var r in e)O(t,r,{get:e[r],enumerable:!0})},We=(t,e,r)=>{if(e&&typeof e=="object"||typeof e=="function")for(let n of Ve(e))!Be.call(t,n)&&n!=="default"&&O(t,n,{get:()=>e[n],enumerable:!(r=Te(e,n))||r.enumerable});return t},d=t=>We(Ge(O(t!=null?Re($e(t)):{},"default",t&&t.__esModule&&"default"in t?{get:()=>t.default,enumerable:!0}:{value:t,enumerable:!0})),t);var ie=S((K,ne)=>{(function(t,e){typeof define=="function"&&define.amd?define([],e):typeof K=="object"?ne.exports=e():t.compareVersions=e()})(K,function(){var t=/^[v^~<>=]*?(\d+)(?:\.([x*]|\d+)(?:\.([x*]|\d+)(?:\.([x*]|\d+))?(?:-([\da-z\-]+(?:\.[\da-z\-]+)*))?(?:\+[\da-z\-]+(?:\.[\da-z\-]+)*)?)?)?$/i;function e(i,s){return i.indexOf(s)===-1?i.length:i.indexOf(s)}function r(i){var s=i.replace(/^v/,"").replace(/\+.*$/,""),p=e(s,"-"),u=s.substring(0,p).split(".");return u.push(s.substring(p+1)),u}function n(i){var s=parseInt(i,10);return isNaN(s)?i:s}function c(i){if(typeof i!="string")throw new TypeError("Invalid argument expected string");var s=i.match(t);if(!s)throw new Error("Invalid argument not valid semver ('"+i+"' received)");return s.shift(),s}function o(i,s){return typeof i!=typeof s?[String(i),String(s)]:[i,s]}function m(i,s){var[p,u]=o(n(i),n(s));return p>u?1:p<u?-1:0}function l(i,s){for(var p=0;p<Math.max(i.length,s.length);p++){var u=m(i[p]||0,s[p]||0);if(u!==0)return u}return 0}function a(i,s){[i,s].forEach(c);for(var p=r(i),u=r(s),f=0;f<Math.max(p.length-1,u.length-1);f++){var E=parseInt(p[f]||0,10),k=parseInt(u[f]||0,10);if(E>k)return 1;if(k>E)return-1}var L=p[p.length-1],R=u[u.length-1];if(L&&R){var v=L.split(".").map(n),P=R.split(".").map(n);for(f=0;f<Math.max(v.length,P.length);f++){if(v[f]===void 0||typeof P[f]=="string"&&typeof v[f]=="number")return-1;if(P[f]===void 0||typeof v[f]=="string"&&typeof P[f]=="number"||v[f]>P[f])return 1;if(P[f]>v[f])return-1}}else if(L||R)return L?-1:1;return 0}var h=[">",">=","=","<","<="],x={">":[1],">=":[0,1],"=":[0],"<=":[-1,0],"<":[-1]};function C(i){if(typeof i!="string")throw new TypeError("Invalid operator type, expected string but got "+typeof i);if(h.indexOf(i)===-1)throw new TypeError("Invalid operator, expected one of "+h.join("|"))}return a.validate=function(i){return typeof i=="string"&&t.test(i)},a.compare=function(i,s,p){C(p);var u=a(i,s);return x[p].indexOf(u)>-1},a.satisfies=function(i,s){var p=s.match(/^([<>=~^]+)/),u=p?p[1]:"=";if(u!=="^"&&u!=="~")return a.compare(i,s,u);var[f,E,k]=c(i),[L,R,v]=c(s);return m(f,L)!==0?!1:u==="^"?l([E,k],[R,v])>=0:m(E,R)!==0?!1:m(k,v)>=0},a})});var fe=S((Ot,J)=>{(function(){"use strict";var t=g("fs"),e=g("string_decoder").StringDecoder;function r(o,m,l,a,h){var x=0,a=a||"utf8",l=l||`
`,h=h||1024,C=new Buffer(h),i="",s=new e(a),p=!1,u=!1,f=-1;function E(){p||(t.close(o,function(v){if(v)throw v}),p=!0)}function k(v){function P(){t.read(o,C,0,h,x,function(N,W){var Q;if(N)throw N;W<h&&(u=!0,E()),x+=W,i+=s.write(C.slice(0,W)),f<0&&(f=i.indexOf(l)),Q=f===i.length-1,W&&(f===-1||Q)&&!u?P():v()})}P()}function L(){return i.length>0||!u}function R(v){function P(){var N=i.substring(0,f);i=i.substring(f+l.length),f=-1,v(N)}if(f<0&&(f=i.indexOf(l)),f<0)if(u)if(L())f=i.length,P();else throw new Error("No more lines to read.");else k(P);else P()}this.hasNextLine=L,this.nextLine=R,this.close=E,k(m)}function n(o,m,l,a,h){t.open(o,"r",parseInt("666",8),function(x,C){var i;if(x)throw x;i=new r(C,function(){m(i)},l,a,h)})}function c(o,m,l,a,h){var x,C=m.length==3;function i(){x&&typeof x=="function"&&x()}return n(o,function(s){function p(){s.hasNextLine()?setImmediate(f):i()}function u(E){E!==!1?p():(i(),s.close())}function f(){s.nextLine(function(E){var k=!s.hasNextLine();C?m(E,k,u):m(E,k)!==!1?p():(i(),s.close())})}p()},l,a,h),{then:function(s){x=s}}}J.exports.open=n,J.exports.eachLine=c})()});var le=S((St,pe)=>{pe.exports=function(t,e){e=e||{},e.listUnicodeChar=e.hasOwnProperty("listUnicodeChar")?e.listUnicodeChar:!1,e.stripListLeaders=e.hasOwnProperty("stripListLeaders")?e.stripListLeaders:!0,e.gfm=e.hasOwnProperty("gfm")?e.gfm:!0;var r=t||"";r=r.replace(/^(-\s*?|\*\s*?|_\s*?){3,}\s*$/gm,"");try{e.stripListLeaders&&(e.listUnicodeChar?r=r.replace(/^([\s\t]*)([\*\-\+]|\d+\.)\s+/gm,e.listUnicodeChar+" $1"):r=r.replace(/^([\s\t]*)([\*\-\+]|\d+\.)\s+/gm,"$1")),e.gfm&&(r=r.replace(/\n={2,}/g,`
`).replace(/~~/g,"").replace(/`{3}.*\n/g,"")),r=r.replace(/<[^>]*>/g,"").replace(/^[=\-]{2,}\s*$/g,"").replace(/\[\^.+?\](\: .*?$)?/g,"").replace(/\s{0,2}\[.*?\]: .*?$/g,"").replace(/\!\[.*?\][\[\(].*?[\]\)]/g,"").replace(/\[(.*?)\][\[\(].*?[\]\)]/g,"$1").replace(/^\s{0,3}>\s?/g,"").replace(/^\s{1,2}\[(.*?)\]: (\S+)( ".*?")?\s*$/g,"").replace(/^(\n)?\s{0,}#{1,6}\s+| {0,}(\n)?\s{0,}#{0,} {0,}(\n)?\s{0,}$/gm,"$1$2$3").replace(/([\*_]{1,3})(\S.*?\S{0,1})\1/g,"$2").replace(/([\*_]{1,3})(\S.*?\S{0,1})\1/g,"$2").replace(/(`{3,})(.*?)\1/gm,"$2").replace(/`(.+?)`/g,"$1").replace(/\n{2,}/g,`

`)}catch(n){return console.error(n),t}return r}});var xe=S((At,de)=>{var G=g("os").EOL,Ae=fe(),Ie=le(),ue=/\[?v?([\w\d.-]+\.[\w\d.-]+[a-zA-Z0-9])\]?/,me=/.*[ ](\d\d?\d?\d?[-/.]\d\d?[-/.]\d\d?\d?\d?).*/,je=/^###/,Me=/^[*-]/,Ue={removeMarkdown:!0};function _e(t,e){if(typeof t=="undefined")throw new Error("missing options argument");if(typeof t=="string"&&(t={filePath:t}),typeof t=="object"){let c=typeof t.filePath!="undefined",o=typeof t.text!="undefined",m=typeof t.filePath!="string",l=typeof t.text!="string";if(!c&&!o)throw new Error("must provide filePath or text");if(c&&m)throw new Error("invalid filePath, expected string");if(o&&l)throw new Error("invalid text, expected string")}let r=Object.assign({},Ue,t),n=Fe(r);return typeof e=="function"&&n.then(function(c){e(null,c)}).catch(function(c){e(c)}),n}function Fe(t){let e=t.filePath,r=t.text,n={log:{versions:[]},current:null},c=De.bind(n,t);return new Promise(function(o,m){function l(){n.current&&ge(n),n.log.description=he(n.log.description),n.log.description===""&&delete n.log.description,o(n.log)}r?(r.split(/\r\n?|\n/mg).forEach(c),l()):Ae.eachLine(e,c,G).then(l)})}function De(t,e){if(!e.match(/^\[[^[\]]*\] *?:/)){if(!this.log.title&&e.match(/^# ?[^#]/)){this.log.title=e.substring(1).trim();return}if(e.match(/^##? ?[^#]/)){this.current&&this.current.title&&ge(this),this.current=qe(),ue.exec(e)&&(this.current.version=ue.exec(e)[1]),this.current.title=e.substring(2).trim(),this.current.title&&me.exec(this.current.title)&&(this.current.date=me.exec(this.current.title)[1]);return}if(this.current){if(this.current.body+=e+G,je.exec(e)){let r=e.replace("###","").trim();this.current.parsed[r]||(this.current.parsed[r]=[],this.current._private.activeSubhead=r)}if(Me.exec(e)){let r=t.removeMarkdown?Ie(e):e;this.current.parsed._.push(r),this.current._private.activeSubhead&&this.current.parsed[this.current._private.activeSubhead].push(r)}}else this.log.description=(this.log.description||"")+e+G}}function qe(){return{version:null,title:null,date:null,body:"",parsed:{_:[]},_private:{activeSubhead:null}}}function ge(t){delete t.current._private,t.current.body=he(t.current.body),t.log.versions.push(t.current)}function he(t){return t?(t=t.trim(),t=t.replace(new RegExp("["+G+"]*"),""),t=t.replace(new RegExp("["+G+"]*$"),""),t):""}de.exports=_e});var Ze={};Ne(Ze,{default:()=>Ke});var T=d(g("@yarnpkg/core")),re=d(g("clipanion"));var w;(function(o){o.MAIN="main",o.PRERELEASE="prerelease",o.RELEASE="release",o.FEATURE="feature",o.UNKNOWN="unknown"})(w||(w={}));var X=d(g("child_process"));async function b(t,e,r){return new Promise((n,c)=>{console.log(">>>",t,...e);let o=(0,X.spawn)(t,e,{cwd:r}),m="",l="";o.stdout.on("data",a=>{m+=a.toString()}),o.stderr.on("data",a=>{l+=a.toString()}),o.on("close",a=>{a===0?n({code:a,result:m}):c(new Error(m+l))})})}async function Y(){return process.env.BUILD_SOURCEBRANCHNAME?process.env.BUILD_SOURCEBRANCHNAME:(await b("git",["rev-parse","--abbrev-ref","HEAD"])).result.replace(/\n*$/,"")}async function ee(t){return b("git",["tag",t])}async function te(t,e){let r=await b("git",["add",...t]);console.log(r.result);let n=await b("git",["commit",...t,"-m",e]);console.log(n.result)}var V="0.0.0",H=class{static async fromContext(e){let r=await T.Configuration.find(e.cwd,e.plugins),n=await Y();return new H(r,n)}constructor(e,r){this.yarnConfig=e;let n=e.get("featureBranchPatterns");console.log(n),console.log(r),this.featureBranchPatterns=n.map(c=>new RegExp(c)),this.mainBranch=e.get("mainBranch"),this.independentVersioning=e.get("independentVersioning"),this.versionTagPrefix=e.get("versionTagPrefix"),this.versionBranch=this.parse(r)}parse(e){if(this.mainBranch===e)return{branchType:w.MAIN,name:e};for(let r of this.featureBranchPatterns)if(r.test(e)){let n=r.exec(e);if(n&&n.length===2)return{name:n[1],branchType:w.FEATURE};throw new re.UsageError(`The feature pattern '${r.source}' matched the current branch but it should result in exact 1 group match`)}return{name:"unknown",branchType:w.UNKNOWN}}},y=H;y.definition={featureBranchPatterns:{description:`Feature branches. This will apply the following rules to bumps:
  - version pattern: 'x.x.x-<<feature>>.<<increment>>'
  - always increment on each commit
  - no checking for conventional commits in git history
  - publish on npm channel '<<feature>>'`,isArray:!0,type:T.SettingsType.STRING,default:["^feature/(.*)$"]},releaseBranchPatterns:{description:`Release branches. This will apply the following rules to bumps:
  - Official release channels
  - Conventional commits enabled
  - publish on npm channel '<<release>>'`,isArray:!0,type:T.SettingsType.STRING,default:["^release/(.*)$"]},mainBranch:{description:"The main branch. This is the official channel and will produce npm packages with the lates npm disttag",type:T.SettingsType.STRING,default:"main"},independentVersioning:{description:"When independent versioning is enabled each package will have a different version based on the commits in the package folder",type:T.SettingsType.BOOLEAN,default:!1},versionTagPrefix:{description:'The prefix used for git tags. Defaults to "v"',type:T.SettingsType.STRING,default:"v"}};var oe=d(g("@yarnpkg/cli")),se=d(g("@yarnpkg/core"));function B(t,e){let r=t;return e&&(e.scope&&(r+=`@${e.scope}/`),r+=e.name,r+="-"),r}async function A(t,e){return Promise.all(t.map(r=>z(r,e)))}async function z(t,e){if(t.manifest.version!==e)return console.log(`@${t.locator.scope}/${t.locator.name}`,t.manifest.version,"=>",e),t.manifest.version=e,t.persistManifest()}var Oe=ie(),$=class extends oe.BaseCommand{async execute(){let e=await y.fromContext(this.context),{project:r}=await se.Project.find(e.yarnConfig,this.context.cwd);if(e.independentVersioning){let n=r.workspaces.map(c=>this.updateWorkspaceFromGit(e.versionTagPrefix,e.versionBranch,c));Promise.all(n)}else{let n=[this.determineCurrentGitVersion(e.versionTagPrefix,e.versionBranch),...r.workspaces.map(o=>this.determineCurrentGitVersion(e.versionTagPrefix,e.versionBranch,o.locator))],c=(await Promise.all(n)).sort(Oe).reverse();await A(r.workspaces,c[0])}}async updateWorkspaceFromGit(e,r,n){let c=await this.determineCurrentGitVersion(e,r,n.locator);return z(n,c)}async determineCurrentGitVersion(e,r,n){let c=B(e,n),o=`${c}*`,a=(await b("git",["-c","versionsort.suffix=-","tag","--sort=-version:refname","--list",o])).result.split(`
`),h=a.filter(s=>new RegExp(`^${this.escapeRegExp(c)}[0-9]+.[0-9]+.[0-9]+$`).test(s));if(r.branchType!==w.MAIN){let s=a.filter(p=>new RegExp(`${c}[0-9]+.[0-9]+.[0-9]+-${this.escapeRegExp(r.name)}.[0-9]+$`).test(p));s.length>0?a=s:a=h}else a=h;a=a.filter(s=>s);let x;a.length>0?x=a[0]:x="0.0.0";let C=x,i=new RegExp(`^${this.escapeRegExp(c)}`);return C=C.replace(i,""),C}escapeRegExp(e){return e.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}};$.paths=[["gitversion","restore"]];var ae=d(g("@yarnpkg/cli")),I=d(g("@yarnpkg/core"));var j=class extends ae.BaseCommand{async execute(){let e=await I.Configuration.find(this.context.cwd,this.context.plugins),{project:r}=await I.Project.find(e,this.context.cwd);await A(r.workspaces,V)}};j.paths=[["gitversion","reset"]];var ce=d(g("@yarnpkg/cli")),M=d(g("@yarnpkg/core"));var Se=["--no-sign","--skip.commit","--skip.tag"];async function Z(t,e,r,n,c){let o=[...Se];if(o.push(`--path='${r}'`),o.push(`--tag-prefix='${e}'`),o.push(`--infile='${r}/CHANGELOG.md'`),c&&(o.push(`--release-as='${c}'`),o.push("--skip.bump")),t.branchType===w.FEATURE)o.push(`--prerelease=${t.name}`,"--skip.changelog"),c||o.push("--release-as=patch");else if(t.branchType===w.PRERELEASE||t.branchType===w.RELEASE)o.push(`--prerelease=${t.name}`);else if(t.branchType===w.UNKNOWN)return;let m=await b("yarn",["standard-version",...o],n);console.log(m.result)}var U=class extends ce.BaseCommand{async execute(){let e=new $;e.context=this.context,e.cli=this.cli,await e.execute();let r=await y.fromContext(this.context),{project:n}=await M.Project.find(r.yarnConfig,this.context.cwd);if(r.independentVersioning)throw new Error("Not implemented");{await Z(r.versionBranch,B(r.versionTagPrefix),n.topLevelWorkspace.cwd,n.topLevelWorkspace.cwd);let o=(await M.Manifest.find(n.topLevelWorkspace.cwd)).version;if(o){let m=n.topLevelWorkspace.getRecursiveWorkspaceChildren().map(async l=>(l.manifest.version=o,await l.persistManifest(),Z(r.versionBranch,B(r.versionTagPrefix),l.cwd,n.topLevelWorkspace.cwd,o)));await Promise.all(m)}}}};U.paths=[["gitversion","bump"]];var ve=d(g("@yarnpkg/cli")),we=d(g("@yarnpkg/core"));var ye=d(g("path"));var He=xe(),_=class extends ve.BaseCommand{async execute(){let e=await y.fromContext(this.context),{project:r}=await we.Project.find(e.yarnConfig,this.context.cwd);if(e.independentVersioning)throw new Error("Not implemented");{let c=r.workspaces.filter(a=>a.manifest.private===!1).map(a=>{let h=[];(e.versionBranch.branchType===w.FEATURE||e.versionBranch.branchType===w.PRERELEASE)&&(h=["--tag",e.versionBranch.name]),b("yarn",["npm","publish",...h],a.cwd)});await Promise.all(c);let o=await He({filePath:(0,ye.join)(r.topLevelWorkspace.cwd,"CHANGELOG.md"),removeMarkdown:!1}),m=r.topLevelWorkspace.manifest.version,l=o.versions.find(a=>a.version===m);l&&await r.configuration.triggerHook(a=>a.afterPublish,r,r.topLevelWorkspace,l)}}};_.paths=[["gitversion","publish"]];var Ee=d(g("@yarnpkg/cli")),Pe=d(g("@yarnpkg/core"));var F=class extends Ee.BaseCommand{async execute(){let e=await y.fromContext(this.context);console.log(e.versionBranch);let{project:r}=await Pe.Project.find(e.yarnConfig,this.context.cwd);r.workspaces.forEach(n=>{console.log(n.locator.scope,n.locator.name,n.manifest.private,n.manifest.version)})}};F.paths=[["gitversion","check"]];var Ce=d(g("@yarnpkg/cli")),ke=d(g("@yarnpkg/core"));var D=class extends Ce.BaseCommand{async execute(){let e=await y.fromContext(this.context),{project:r}=await ke.Project.find(e.yarnConfig,this.context.cwd);if(e.independentVersioning)throw new Error("Not implemented");{let n=r.topLevelWorkspace.manifest.version;n&&n!==V&&await ee(`${e.versionTagPrefix}${n}`)}}};D.paths=[["gitversion","tag"]];var be=d(g("@yarnpkg/cli")),Le=d(g("@yarnpkg/core"));var q=class extends be.BaseCommand{async execute(){let e=await y.fromContext(this.context),{project:r}=await Le.Project.find(e.yarnConfig,this.context.cwd);if(e.independentVersioning)throw new Error("Not implemented");{let n=r.topLevelWorkspace.manifest.version;n&&n!==V&&await te(["**/CHANGELOG.md"],`chore(release): ${n}`)}}};q.paths=[["gitversion","commit"]];var ze={configuration:y.definition,commands:[F,$,j,U,D,q,_],hooks:{async wrapNetworkRequest(t,e){return t}}},Ke=ze;return Ze;})();
return plugin;
}
};
