/* eslint-disable */
//prettier-ignore
module.exports = {
name: "@yarnpkg/plugin-gitversion",
factory: function (require) {
var plugin=(()=>{var ke=Object.create,O=Object.defineProperty;var Ce=Object.getOwnPropertyDescriptor;var be=Object.getOwnPropertyNames;var Le=Object.getPrototypeOf,Te=Object.prototype.hasOwnProperty;var Re=t=>O(t,"__esModule",{value:!0});var d=t=>{if(typeof require!="undefined")return require(t);throw new Error('Dynamic require of "'+t+'" is not supported')};var S=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),Ve=(t,e)=>{for(var r in e)O(t,r,{get:e[r],enumerable:!0})},$e=(t,e,r)=>{if(e&&typeof e=="object"||typeof e=="function")for(let n of be(e))!Te.call(t,n)&&n!=="default"&&O(t,n,{get:()=>e[n],enumerable:!(r=Ce(e,n))||r.enumerable});return t},v=t=>$e(Re(O(t!=null?ke(Le(t)):{},"default",t&&t.__esModule&&"default"in t?{get:()=>t.default,enumerable:!0}:{value:t,enumerable:!0})),t);var re=S((z,te)=>{(function(t,e){typeof define=="function"&&define.amd?define([],e):typeof z=="object"?te.exports=e():t.compareVersions=e()})(z,function(){var t=/^[v^~<>=]*?(\d+)(?:\.([x*]|\d+)(?:\.([x*]|\d+)(?:\.([x*]|\d+))?(?:-([\da-z\-]+(?:\.[\da-z\-]+)*))?(?:\+[\da-z\-]+(?:\.[\da-z\-]+)*)?)?)?$/i;function e(i,o){return i.indexOf(o)===-1?i.length:i.indexOf(o)}function r(i){var o=i.replace(/^v/,"").replace(/\+.*$/,""),p=e(o,"-"),l=o.substring(0,p).split(".");return l.push(o.substring(p+1)),l}function n(i){var o=parseInt(i,10);return isNaN(o)?i:o}function a(i){if(typeof i!="string")throw new TypeError("Invalid argument expected string");var o=i.match(t);if(!o)throw new Error("Invalid argument not valid semver ('"+i+"' received)");return o.shift(),o}function s(i,o){return typeof i!=typeof o?[String(i),String(o)]:[i,o]}function u(i,o){var[p,l]=s(n(i),n(o));return p>l?1:p<l?-1:0}function m(i,o){for(var p=0;p<Math.max(i.length,o.length);p++){var l=u(i[p]||0,o[p]||0);if(l!==0)return l}return 0}function c(i,o){[i,o].forEach(a);for(var p=r(i),l=r(o),f=0;f<Math.max(p.length-1,l.length-1);f++){var P=parseInt(p[f]||0,10),C=parseInt(l[f]||0,10);if(P>C)return 1;if(C>P)return-1}var b=p[p.length-1],T=l[l.length-1];if(b&&T){var x=b.split(".").map(n),E=T.split(".").map(n);for(f=0;f<Math.max(x.length,E.length);f++){if(x[f]===void 0||typeof E[f]=="string"&&typeof x[f]=="number")return-1;if(E[f]===void 0||typeof x[f]=="string"&&typeof E[f]=="number"||x[f]>E[f])return 1;if(E[f]>x[f])return-1}}else if(b||T)return b?-1:1;return 0}var g=[">",">=","=","<","<="],h={">":[1],">=":[0,1],"=":[0],"<=":[-1,0],"<":[-1]};function k(i){if(typeof i!="string")throw new TypeError("Invalid operator type, expected string but got "+typeof i);if(g.indexOf(i)===-1)throw new TypeError("Invalid operator, expected one of "+g.join("|"))}return c.validate=function(i){return typeof i=="string"&&t.test(i)},c.compare=function(i,o,p){k(p);var l=c(i,o);return h[p].indexOf(l)>-1},c.satisfies=function(i,o){var p=o.match(/^([<>=~^]+)/),l=p?p[1]:"=";if(l!=="^"&&l!=="~")return c.compare(i,o,l);var[f,P,C]=a(i),[b,T,x]=a(o);return u(f,b)!==0?!1:l==="^"?m([P,C],[T,x])>=0:u(P,T)!==0?!1:u(C,x)>=0},c})});var fe=S((Ot,Z)=>{(function(){"use strict";var t=d("fs"),e=d("string_decoder").StringDecoder;function r(s,u,m,c,g){var h=0,c=c||"utf8",m=m||`
`,g=g||1024,k=new Buffer(g),i="",o=new e(c),p=!1,l=!1,f=-1;function P(){p||(t.close(s,function(x){if(x)throw x}),p=!0)}function C(x){function E(){t.read(s,k,0,g,h,function(G,N){var J;if(G)throw G;N<g&&(l=!0,P()),h+=N,i+=o.write(k.slice(0,N)),f<0&&(f=i.indexOf(m)),J=f===i.length-1,N&&(f===-1||J)&&!l?E():x()})}E()}function b(){return i.length>0||!l}function T(x){function E(){var G=i.substring(0,f);i=i.substring(f+m.length),f=-1,x(G)}if(f<0&&(f=i.indexOf(m)),f<0)if(l)if(b())f=i.length,E();else throw new Error("No more lines to read.");else C(E);else E()}this.hasNextLine=b,this.nextLine=T,this.close=P,C(u)}function n(s,u,m,c,g){t.open(s,"r",parseInt("666",8),function(h,k){var i;if(h)throw h;i=new r(k,function(){u(i)},m,c,g)})}function a(s,u,m,c,g){var h,k=u.length==3;function i(){h&&typeof h=="function"&&h()}return n(s,function(o){function p(){o.hasNextLine()?setImmediate(f):i()}function l(P){P!==!1?p():(i(),o.close())}function f(){o.nextLine(function(P){var C=!o.hasNextLine();k?u(P,C,l):u(P,C)!==!1?p():(i(),o.close())})}p()},m,c,g),{then:function(o){h=o}}}Z.exports.open=n,Z.exports.eachLine=a})()});var le=S((St,pe)=>{pe.exports=function(t,e){e=e||{},e.listUnicodeChar=e.hasOwnProperty("listUnicodeChar")?e.listUnicodeChar:!1,e.stripListLeaders=e.hasOwnProperty("stripListLeaders")?e.stripListLeaders:!0,e.gfm=e.hasOwnProperty("gfm")?e.gfm:!0;var r=t||"";r=r.replace(/^(-\s*?|\*\s*?|_\s*?){3,}\s*$/gm,"");try{e.stripListLeaders&&(e.listUnicodeChar?r=r.replace(/^([\s\t]*)([\*\-\+]|\d+\.)\s+/gm,e.listUnicodeChar+" $1"):r=r.replace(/^([\s\t]*)([\*\-\+]|\d+\.)\s+/gm,"$1")),e.gfm&&(r=r.replace(/\n={2,}/g,`
`).replace(/~~/g,"").replace(/`{3}.*\n/g,"")),r=r.replace(/<[^>]*>/g,"").replace(/^[=\-]{2,}\s*$/g,"").replace(/\[\^.+?\](\: .*?$)?/g,"").replace(/\s{0,2}\[.*?\]: .*?$/g,"").replace(/\!\[.*?\][\[\(].*?[\]\)]/g,"").replace(/\[(.*?)\][\[\(].*?[\]\)]/g,"$1").replace(/^\s{0,3}>\s?/g,"").replace(/^\s{1,2}\[(.*?)\]: (\S+)( ".*?")?\s*$/g,"").replace(/^(\n)?\s{0,}#{1,6}\s+| {0,}(\n)?\s{0,}#{0,} {0,}(\n)?\s{0,}$/gm,"$1$2$3").replace(/([\*_]{1,3})(\S.*?\S{0,1})\1/g,"$2").replace(/([\*_]{1,3})(\S.*?\S{0,1})\1/g,"$2").replace(/(`{3,})(.*?)\1/gm,"$2").replace(/`(.+?)`/g,"$1").replace(/\n{2,}/g,`

`)}catch(n){return console.error(n),t}return r}});var xe=S((At,de)=>{var W=d("os").EOL,Ge=fe(),Ne=le(),ue=/\[?v?([\w\d.-]+\.[\w\d.-]+[a-zA-Z0-9])\]?/,me=/.*[ ](\d\d?\d?\d?[-/.]\d\d?[-/.]\d\d?\d?\d?).*/,Oe=/^###/,Se=/^[*-]/,Ae={removeMarkdown:!0};function Ie(t,e){if(typeof t=="undefined")throw new Error("missing options argument");if(typeof t=="string"&&(t={filePath:t}),typeof t=="object"){let a=typeof t.filePath!="undefined",s=typeof t.text!="undefined",u=typeof t.filePath!="string",m=typeof t.text!="string";if(!a&&!s)throw new Error("must provide filePath or text");if(a&&u)throw new Error("invalid filePath, expected string");if(s&&m)throw new Error("invalid text, expected string")}let r=Object.assign({},Ae,t),n=je(r);return typeof e=="function"&&n.then(function(a){e(null,a)}).catch(function(a){e(a)}),n}function je(t){let e=t.filePath,r=t.text,n={log:{versions:[]},current:null},a=Ue.bind(n,t);return new Promise(function(s,u){function m(){n.current&&ge(n),n.log.description=he(n.log.description),n.log.description===""&&delete n.log.description,s(n.log)}r?(r.split(/\r\n?|\n/mg).forEach(a),m()):Ge.eachLine(e,a,W).then(m)})}function Ue(t,e){if(!e.match(/^\[[^[\]]*\] *?:/)){if(!this.log.title&&e.match(/^# ?[^#]/)){this.log.title=e.substring(1).trim();return}if(e.match(/^##? ?[^#]/)){this.current&&this.current.title&&ge(this),this.current=Me(),ue.exec(e)&&(this.current.version=ue.exec(e)[1]),this.current.title=e.substring(2).trim(),this.current.title&&me.exec(this.current.title)&&(this.current.date=me.exec(this.current.title)[1]);return}if(this.current){if(this.current.body+=e+W,Oe.exec(e)){let r=e.replace("###","").trim();this.current.parsed[r]||(this.current.parsed[r]=[],this.current._private.activeSubhead=r)}if(Se.exec(e)){let r=t.removeMarkdown?Ne(e):e;this.current.parsed._.push(r),this.current._private.activeSubhead&&this.current.parsed[this.current._private.activeSubhead].push(r)}}else this.log.description=(this.log.description||"")+e+W}}function Me(){return{version:null,title:null,date:null,body:"",parsed:{_:[]},_private:{activeSubhead:null}}}function ge(t){delete t.current._private,t.current.body=he(t.current.body),t.log.versions.push(t.current)}function he(t){return t?(t=t.trim(),t=t.replace(new RegExp("["+W+"]*"),""),t=t.replace(new RegExp("["+W+"]*$"),""),t):""}de.exports=Ie});var qe={};Ve(qe,{default:()=>De});var R=v(d("@yarnpkg/core")),ee=v(d("clipanion"));var w;(function(s){s.MAIN="main",s.PRERELEASE="prerelease",s.RELEASE="release",s.FEATURE="feature",s.UNKNOWN="unknown"})(w||(w={}));var Q=v(d("child_process"));async function L(t,e,r){return new Promise((n,a)=>{console.log(">>>",t,...e);let s=(0,Q.spawn)(t,e,{cwd:r}),u="",m="";s.stdout.on("data",c=>{u+=c.toString()}),s.stderr.on("data",c=>{m+=c.toString()}),s.on("close",c=>{c===0?n({code:c,result:u}):a(new Error(u+m))})})}async function X(){return process.env.BUILD_SOURCEBRANCHNAME?process.env.BUILD_SOURCEBRANCHNAME:(await L("git",["rev-parse","--abbrev-ref","HEAD"])).result.replace(/\n*$/,"")}async function Y(t){return L("git",["tag",t])}var A="0.0.0",q=class{static async fromContext(e){let r=await R.Configuration.find(e.cwd,e.plugins),n=await X();return new q(r,n)}constructor(e,r){this.yarnConfig=e;let n=e.get("featureBranchPatterns");console.log(n),console.log(r),this.featureBranchPatterns=n.map(a=>new RegExp(a)),this.mainBranch=e.get("mainBranch"),this.independentVersioning=e.get("independentVersioning"),this.versionTagPrefix=e.get("versionTagPrefix"),this.versionBranch=this.parse(r)}parse(e){if(this.mainBranch===e)return{branchType:w.MAIN,name:e};for(let r of this.featureBranchPatterns)if(r.test(e)){let n=r.exec(e);if(n&&n.length===2)return{name:n[1],branchType:w.FEATURE};throw new ee.UsageError(`The feature pattern '${r.source}' matched the current branch but it should result in exact 1 group match`)}return{name:"unknown",branchType:w.UNKNOWN}}},y=q;y.definition={featureBranchPatterns:{description:`Feature branches. This will apply the following rules to bumps:
  - version pattern: 'x.x.x-<<feature>>.<<increment>>'
  - always increment on each commit
  - no checking for conventional commits in git history
  - publish on npm channel '<<feature>>'`,isArray:!0,type:R.SettingsType.STRING,default:["^feature/(.*)$"]},releaseBranchPatterns:{description:`Release branches. This will apply the following rules to bumps:
  - Official release channels
  - Conventional commits enabled
  - publish on npm channel '<<release>>'`,isArray:!0,type:R.SettingsType.STRING,default:["^release/(.*)$"]},mainBranch:{description:"The main branch. This is the official channel and will produce npm packages with the lates npm disttag",type:R.SettingsType.STRING,default:"main"},independentVersioning:{description:"When independent versioning is enabled each package will have a different version based on the commits in the package folder",type:R.SettingsType.BOOLEAN,default:!1},versionTagPrefix:{description:'The prefix used for git tags. Defaults to "v"',type:R.SettingsType.STRING,default:"v"}};var ne=v(d("@yarnpkg/cli")),ie=v(d("@yarnpkg/core"));function B(t,e){let r=t;return e&&(e.scope&&(r+=`@${e.scope}/`),r+=e.name,r+="-"),r}async function I(t,e){return Promise.all(t.map(r=>H(r,e)))}async function H(t,e){if(t.manifest.version!==e)return console.log(`@${t.locator.scope}/${t.locator.name}`,t.manifest.version,"=>",e),t.manifest.version=e,t.persistManifest()}var Be=re(),V=class extends ne.BaseCommand{async execute(){let e=await y.fromContext(this.context),{project:r}=await ie.Project.find(e.yarnConfig,this.context.cwd);if(e.independentVersioning){let n=r.workspaces.map(a=>this.updateWorkspaceFromGit(e.versionTagPrefix,e.versionBranch,a));Promise.all(n)}else{let n=[this.determineCurrentGitVersion(e.versionTagPrefix,e.versionBranch),...r.workspaces.map(s=>this.determineCurrentGitVersion(e.versionTagPrefix,e.versionBranch,s.locator))],a=(await Promise.all(n)).sort(Be).reverse();await I(r.workspaces,a[0])}}async updateWorkspaceFromGit(e,r,n){let a=await this.determineCurrentGitVersion(e,r,n.locator);return H(n,a)}async determineCurrentGitVersion(e,r,n){let a=B(e,n),s=`${a}*`,c=(await L("git",["-c","versionsort.suffix=-","tag","--sort=-version:refname","--list",s])).result.split(`
`),g=c.filter(o=>new RegExp(`^${this.escapeRegExp(a)}[0-9]+.[0-9]+.[0-9]+$`).test(o));if(r.branchType!==w.MAIN){let o=c.filter(p=>new RegExp(`${a}[0-9]+.[0-9]+.[0-9]+-${this.escapeRegExp(r.name)}.[0-9]+$`).test(p));o.length>0?c=o:c=g}else c=g;c=c.filter(o=>o);let h;c.length>0?h=c[0]:h="0.0.0";let k=h,i=new RegExp(`^${this.escapeRegExp(a)}`);return k=k.replace(i,""),k}escapeRegExp(e){return e.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}};V.paths=[["gitversion","restore"]];var oe=v(d("@yarnpkg/cli")),j=v(d("@yarnpkg/core"));var U=class extends oe.BaseCommand{async execute(){let e=await j.Configuration.find(this.context.cwd,this.context.plugins),{project:r}=await j.Project.find(e,this.context.cwd);await I(r.workspaces,A)}};U.paths=[["gitversion","reset"]];var se=v(d("@yarnpkg/cli")),M=v(d("@yarnpkg/core"));var We=["--no-sign","--skip.commit","--skip.tag"];async function K(t,e,r,n,a){let s=[...We];if(s.push(`--path=${r}`),s.push(`--tag-prefix='${e}'`),s.push(`--infile=${r}/CHANGELOG.md`),a&&s.push(`--release-as=${a}`),t.branchType===w.FEATURE)s.push(`--prerelease=${t.name}`,"--skip.changelog"),a||s.push("--release-as=patch");else if(t.branchType===w.PRERELEASE)s.push(`--prerelease=${t.name}`);else if(t.branchType===w.UNKNOWN)return;let u=await L("yarn",["standard-version",...s],n);console.log(u)}var _=class extends se.BaseCommand{async execute(){let e=new V;e.context=this.context,e.cli=this.cli,await e.execute();let r=await y.fromContext(this.context),{project:n}=await M.Project.find(r.yarnConfig,this.context.cwd);if(r.independentVersioning)throw new Error("Not implemented");{await K(r.versionBranch,B(r.versionTagPrefix),n.topLevelWorkspace.cwd,n.topLevelWorkspace.cwd);let s=(await M.Manifest.find(n.topLevelWorkspace.cwd)).version;if(s){let u=n.topLevelWorkspace.getRecursiveWorkspaceChildren().map(m=>K(r.versionBranch,B(r.versionTagPrefix),m.cwd,n.topLevelWorkspace.cwd,s));await Promise.all(u)}}}};_.paths=[["gitversion","bump"]];var ve=v(d("@yarnpkg/cli")),we=v(d("@yarnpkg/core"));var ye=v(d("path"));var ae=v(d("@yarnpkg/cli")),ce=v(d("@yarnpkg/core"));var $=class extends ae.BaseCommand{async execute(){let e=await y.fromContext(this.context),{project:r}=await ce.Project.find(e.yarnConfig,this.context.cwd);if(e.independentVersioning)throw new Error("Not implemented");{let n=r.topLevelWorkspace.manifest.version;n&&n!==A&&await Y(`${e.versionTagPrefix}${n}`)}}};$.paths=[["gitversion","tag"]];var _e=xe(),F=class extends ve.BaseCommand{async execute(){let e=new $;e.context=this.context,e.cli=this.cli,await e.execute();let r=await y.fromContext(this.context),{project:n}=await we.Project.find(r.yarnConfig,this.context.cwd);if(r.independentVersioning)throw new Error("Not implemented");{let s=n.workspaces.filter(g=>g.manifest.private===!1).map(g=>{let h=[];(r.versionBranch.branchType===w.FEATURE||r.versionBranch.branchType===w.PRERELEASE)&&(h=["--tag",r.versionBranch.name]),L("yarn",["npm","publish",...h],g.cwd)});await Promise.all(s);let u=await _e({filePath:(0,ye.join)(n.topLevelWorkspace.cwd,"CHANGELOG.md"),removeMarkdown:!1}),m=n.topLevelWorkspace.manifest.version,c=u.versions.find(g=>g.version===m);c&&await n.configuration.triggerHook(g=>g.afterPublish,n,n.topLevelWorkspace,c)}}};F.paths=[["gitversion","publish"]];var Pe=v(d("@yarnpkg/cli")),Ee=v(d("@yarnpkg/core"));var D=class extends Pe.BaseCommand{async execute(){let e=await y.fromContext(this.context);console.log(e.versionBranch);let{project:r}=await Ee.Project.find(e.yarnConfig,this.context.cwd);r.workspaces.forEach(n=>{console.log(n.locator.scope,n.locator.name,n.manifest.private,n.manifest.version)})}};D.paths=[["gitversion","check"]];var Fe={configuration:y.definition,commands:[D,V,U,_,$,F],hooks:{async wrapNetworkRequest(t,e){return t}}},De=Fe;return qe;})();
return plugin;
}
};
